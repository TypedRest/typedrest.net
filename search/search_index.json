{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00b6 TypedRest helps you build type-safe, fluent-style REST API clients. Common REST patterns such as collections are represented as classes, allowing you to write more idiomatic code. C# var client = new MyClient ( new Uri ( \"http://example.com/\" )); // GET /contacts List < Contact > contactList = await client . Contacts . ReadAllAsync (); // POST /contacts -> Location: /contacts/1337 ContactEndpoint smith = await client . Contacts . CreateAsync ( new Contact { Name = \"Smith\" }); //ContactEndpoint smith = client.Contacts[\"1337\"]; // GET /contacts/1337 Contact contact = await smith . ReadAsync (); // PUT /contacts/1337/note await smith . Note . SetAsync ( new Note { Content = \"some note\" }); // GET /contacts/1337/note Note note = await smith . Note . ReadAsync (); // DELETE /contacts/1337 await smith . DeleteAsync (); Java MyClient client = new MyClient ( URI . create ( \"http://example.com/\" )); // GET /contacts List < Contact > contactList = client . getContacts (). readAll (); // POST /contacts -> Location: /contacts/1337 ContactEndpoint smith = client . getContacts (). create ( new Contact ( \"Smith\" )); //ContactEndpoint smith = client.getContacts().get(\"1337\"); // GET /contacts/1337 Contact contact = smith . read (); // PUT /contacts/1337/note smith . getNote (). set ( new Note ( \"some note\" )); // GET /contacts/1337/note Note note = smith . getNote (). read (); // DELETE /contacts/1337 smith . delete (); Kotlin val client = MyClient ( URI . create ( \"http://example.com/\" )) // GET /contacts val contactList : List < Contact > = client . contacts . readAll () // POST /contacts -> Location: /contacts/1337 val smith : ContactEndpoint = client . contacts . create ( Contact ( \"Smith\" )) //val smith: ContactEndpoint = client.contacts[\"1337\"] // GET /contacts/1337 val contact : Contact = smith . read () // PUT /contacts/1337/note smith . note . set ( Note ( \"some note\" )) // GET /contacts/1337/note val note : Note = smith . note . read () // DELETE /contacts/1337 smith . delete () TypeScript const client = new MyClient ( new URL ( \"http://example.com/\" )); // GET /contacts const contactList : Contact [] = await client . contacts . readAll (); // POST /contacts -> Location: /contacts/1337 const smith : ContactEndpoint = await client . contacts . create ({ name : \"Smith\" }); //const smith: ContactEndpoint = client.contacts.get(\"1337\"); // GET /contacts/1337 const contact : Contact = await smith . read (); // PUT /contacts/1337/note await smith . note . set ({ content : \"some note\" }); // GET /contacts/1337/note const note : Note = await smith . note . read (); // DELETE /contacts/1337 await smith . delete (); Documentation \u00b6 Introduction What is TypedRest and how can it help me? Getting Started How do I use TypedRest in my projects? Endpoints Documentation for all endpoint types provided by TypedRest. Error handling How to handle API errors with TypedRest. Link handling How to handle relative URIs, link headers, HATEOS, etc. with TypedRest. Code generation Auto-generate code for TypedRest from Swagger/OpenAPI sepc.","title":"Home"},{"location":"#_1","text":"TypedRest helps you build type-safe, fluent-style REST API clients. Common REST patterns such as collections are represented as classes, allowing you to write more idiomatic code. C# var client = new MyClient ( new Uri ( \"http://example.com/\" )); // GET /contacts List < Contact > contactList = await client . Contacts . ReadAllAsync (); // POST /contacts -> Location: /contacts/1337 ContactEndpoint smith = await client . Contacts . CreateAsync ( new Contact { Name = \"Smith\" }); //ContactEndpoint smith = client.Contacts[\"1337\"]; // GET /contacts/1337 Contact contact = await smith . ReadAsync (); // PUT /contacts/1337/note await smith . Note . SetAsync ( new Note { Content = \"some note\" }); // GET /contacts/1337/note Note note = await smith . Note . ReadAsync (); // DELETE /contacts/1337 await smith . DeleteAsync (); Java MyClient client = new MyClient ( URI . create ( \"http://example.com/\" )); // GET /contacts List < Contact > contactList = client . getContacts (). readAll (); // POST /contacts -> Location: /contacts/1337 ContactEndpoint smith = client . getContacts (). create ( new Contact ( \"Smith\" )); //ContactEndpoint smith = client.getContacts().get(\"1337\"); // GET /contacts/1337 Contact contact = smith . read (); // PUT /contacts/1337/note smith . getNote (). set ( new Note ( \"some note\" )); // GET /contacts/1337/note Note note = smith . getNote (). read (); // DELETE /contacts/1337 smith . delete (); Kotlin val client = MyClient ( URI . create ( \"http://example.com/\" )) // GET /contacts val contactList : List < Contact > = client . contacts . readAll () // POST /contacts -> Location: /contacts/1337 val smith : ContactEndpoint = client . contacts . create ( Contact ( \"Smith\" )) //val smith: ContactEndpoint = client.contacts[\"1337\"] // GET /contacts/1337 val contact : Contact = smith . read () // PUT /contacts/1337/note smith . note . set ( Note ( \"some note\" )) // GET /contacts/1337/note val note : Note = smith . note . read () // DELETE /contacts/1337 smith . delete () TypeScript const client = new MyClient ( new URL ( \"http://example.com/\" )); // GET /contacts const contactList : Contact [] = await client . contacts . readAll (); // POST /contacts -> Location: /contacts/1337 const smith : ContactEndpoint = await client . contacts . create ({ name : \"Smith\" }); //const smith: ContactEndpoint = client.contacts.get(\"1337\"); // GET /contacts/1337 const contact : Contact = await smith . read (); // PUT /contacts/1337/note await smith . note . set ({ content : \"some note\" }); // GET /contacts/1337/note const note : Note = await smith . note . read (); // DELETE /contacts/1337 await smith . delete ();","title":""},{"location":"#documentation","text":"Introduction What is TypedRest and how can it help me? Getting Started How do I use TypedRest in my projects? Endpoints Documentation for all endpoint types provided by TypedRest. Error handling How to handle API errors with TypedRest. Link handling How to handle relative URIs, link headers, HATEOS, etc. with TypedRest. Code generation Auto-generate code for TypedRest from Swagger/OpenAPI sepc.","title":"Documentation"},{"location":"introduction/","text":"Introduction \u00b6 There have been innumerable papers, posts and articles providing guidelines on how to design RESTful web services. Most of these guidelines are intended to make the behavior of web services more predictable for humans and machines alike. For example, the appropriate use of HTTP verbs allows developers to easily distinguish safe operations (such as GET and HEAD ) from unsafe operations (such as POST and DELETE ). Intermediate proxy servers can use this same information to determine candidates for caching. The plethora of HTTP headers provide many additional ways to express metadata and API structure in a standardized form. The \"old\" way \u00b6 While this slowly evolving consensus on \"the right way\" to design new APIs makes understanding such APIs easier, it does not necessarily help when actually consuming them. While HTTP libraries and tools expose all the underlying components (HTTP verbs/methods, headers, etc.) the burden of actually interpreting and combining all the pieces still lies with the developer. Let us take a look at an example: Assume the URI /contacts/ represents a collection of address book entries. GET ing the collection itself returns all entries. GET ing an URI like /contacts/1337 gives you a specific entry. POST ing to the collection adds a new element to it and returns the URI of the newly created resource using the Location header. Pretty standard stuff, right? The problem is that all this knowledge currently only exists in your head. When you actually perform operations on the collection in your code you are usually manually building your GET s and your POST s while serializing and deserializing message bodies to and from JSON. C# var client = new HttpClient { BaseAddress = new Uri ( \"http://example.com/\" )}; var contactsResponse = await client . GetAsync ( \"contacts\" ); var contactList = await contactsResponse . Content . ReadAsAsync < List < Contact >>(); var createResponse = await client . PostAsJsonAsync ( \"contacts\" , new Contact { Name = \"Smith\" }); var contactUri = createResponse . Headers . Location ; //var contactUri = new Uri(\"contacts/1337\", UriKind.Relative); var contactResponse = await client . GetAsync ( contactUri ); var contact = await contactResponse . Content . ReadAsAsync < Contact >(); TypeScript const contactsResponse = await fetch ( \"http://example.com/contacts\" ); const contactList = ( await contactsResponse . json ()) as Contact []; const createResponse = await fetch ( \"http://example.com/contacts\" , { body : JSON.stringify ({ name : \"Smith\" }) }); const contactUri = createResponse . headers . get ( \"Location\" ); //const contactUri = \"http://example.com/contacts/1337\" const contactResponse = await fetch ( contactUri ); const contact = ( await contactResponse . json ()) as Contact ; Better with TypedRest \u00b6 This is where TypedRest comes in. TypedRest is a set of libraries for consuming RESTful APIs that behave in a \"predictable\" way. Rather than applying your knowledge about how a REST collection usually behaves you simply tell TypedRest that this particular endpoint is a collection and get a collection-like interface in return. C# var client = new EntryEndpoint ( new Uri ( \"http://example.com/\" )); var contacts = new CollectionEndpoint < Contact >( client , relativeUri : \"./contacts\" ); var contactList = await contacts . ReadAllAsync (); var smith = await contacts . CreateAsync ( new Contact { Name = \"Smith\" }); //var smith = contacts[\"1337\"]; var contact = await smith . ReadAsync (); TypeScript const client = new EntryEndpoint ( new URL ( \"http://example.com/\" )); const contacts = new CollectionEndpoint < Contact > ( client , \"./contacts\" ); const contactList = await contacts . readAll (); const smith = await contacts . create ({ name : \"Smith\" }); //const smith = contacts.get(\"1337\"); const contact = await smith . read (); Endpoints \u00b6 TypedRest uses an object-oriented approach to provide you with building blocks for modeling RESTful endpoints . Behavior of endpoints is described by inheritance while navigation between them is described by composition. For example, we could redesign our sample from above to make the service's functionality easy to discover and consume using code completion: C# class MyClient : EntryEndpoint { public MyClient ( Uri uri ) : base ( uri ) {} public ICollectionEndpoint < Contact > Contacts => new CollectionEndpoint < Contact >( this , relativeUri : \"./contacts\" ); } TypeScript class MyClient extends EntryEndpoint { get contacts () { return new CollectionEndpoint < Contact > ( this , \"./contacts\" ); } } The consuming code could look this: C# var client = new MyClient ( new Uri ( \"http://example.com/\" )); var contactList = await client . Contacts . ReadAllAsync (); var smith = await client . Contacts . CreateAsync ( new Contact { Name = \"Smith\" }); var contact = await smith . ReadAsync (); TypeScript const client = new MyClient ( new URL ( \"http://example.com/\" )); const contactList = await client . contacts . readAll (); const smith = await client . contacts . create ({ name : \"Smith\" }); const contact = await smith . read (); Patterns \u00b6 TypedRest is all about nomenclature and patterns. An endpoint describes any resource addressable via an URI. An entry endpoint represents the top-level URI of an API. It takes care of shared concerns such as authentication. An element endpoint is a singular resource that can be read, modified and deleted. A collection endpoint can list and add elements as well as provide element endpoints for individual elements. There are also a number of more specialized endpoint types such as streaming-capable collections . Each of these endpoint types has one or more corresponding classes in TypedRest. The only requirement on the server-side is that at least a part of the underlying pattern is implemented. For example, a collection endpoint class works as long as the server responds with an array of elements when GET ting the collection while GET ting a child endpoint provides a specific element of the same type. If adding new elements via POST is not supported (yet) this will simply result in an exception at runtime when calling .CreateAsync() . For more graceful degradation TypedRest also exposes information about \"allowed\" methods as reported by OPTIONS . We consider TypedRest's design to be opinionated yet pragmatic. The path of least resistance is to make your API match the patterns implemented in the built-in classes. These usually align with what is widely considered as \"best practice\". However: We explicitly support some unRESTful concepts such as RPC endpoints. HATEOAS-style, link-based navigation is possible but entirely optional. Link information is preferably encoded in HTTP Link headers instead of response bodies, although the latter is also supported in form of HAL. TypedRest does not use custom MIME types for API versioning, navigation, etc.. Of course, we don't expect our predefined patterns to cover all possible use cases. This where good old \"extension through inheritance\" comes into play. Let's say our sample API from above also allows us to store a note associated with a contact. We need to extend ElementEndpoint for individual Contact instances to expose this functionality. We also need to replace CollectionEndpoint with something that builds instances of our specialized element endpoint rather than using ElementEndpoint . Let's get coding! C# class MyClient : EntryEndpoint { public MyClient ( Uri uri ) : base ( uri ) {} public ContactCollectionEndpoint Contacts => new ContactCollectionEndpoint ( this ); } class ContactCollectionEndpoint : CollectionEndpoint < Contact , ContactEndpoint > { public ContactCollectionEndpoint ( IEndpoint referrer ) : base ( referrer , relativeUri : \"./contacts\" ) {} } class ContactEndpoint : ElementEndpoint < Contact > { public ContactEndpoint ( IEndpoint referrer , Uri relativeUri ) : base ( referrer , relativeUri ) {} public IElementEndpoint < Note > Note => new ElementEndpoint < Note >( this , relativeUri : \"./note\" ); } TypeScript class MyClient extends EntryEndpoint { get contacts () { return new ContactCollectionEndpoint ( this ); } } class ContactCollectionEndpoint extends GenericCollectionEndpoint < Contact , ContactEndpoint > { constructor ( referrer : Endpoint ) { super ( referrer , \"./contacts\" , ContactEndpoint ); } } class ContactEndpoint extends ElementEndpoint < Contact > { get note () { return new ElementEndpoint < Note > ( this , \"./note\" ); } } The consuming code could look this: C# var client = new MyClient ( new Uri ( \"http://example.com/\" )); await client . Contacts [ \"1337\" ]. Note . SetAsync ( new Note { Content = \"some note\" }); TypeScript const client = new MyClient ( new URL ( \"http://example.com/\" )); await client . contacts . get ( \"1337\" ). note . set ({ content : \"some note\" }); Next steps \u00b6 Continue on to the Getting started guide.","title":"Introduction"},{"location":"introduction/#introduction","text":"There have been innumerable papers, posts and articles providing guidelines on how to design RESTful web services. Most of these guidelines are intended to make the behavior of web services more predictable for humans and machines alike. For example, the appropriate use of HTTP verbs allows developers to easily distinguish safe operations (such as GET and HEAD ) from unsafe operations (such as POST and DELETE ). Intermediate proxy servers can use this same information to determine candidates for caching. The plethora of HTTP headers provide many additional ways to express metadata and API structure in a standardized form.","title":"Introduction"},{"location":"introduction/#the-old-way","text":"While this slowly evolving consensus on \"the right way\" to design new APIs makes understanding such APIs easier, it does not necessarily help when actually consuming them. While HTTP libraries and tools expose all the underlying components (HTTP verbs/methods, headers, etc.) the burden of actually interpreting and combining all the pieces still lies with the developer. Let us take a look at an example: Assume the URI /contacts/ represents a collection of address book entries. GET ing the collection itself returns all entries. GET ing an URI like /contacts/1337 gives you a specific entry. POST ing to the collection adds a new element to it and returns the URI of the newly created resource using the Location header. Pretty standard stuff, right? The problem is that all this knowledge currently only exists in your head. When you actually perform operations on the collection in your code you are usually manually building your GET s and your POST s while serializing and deserializing message bodies to and from JSON. C# var client = new HttpClient { BaseAddress = new Uri ( \"http://example.com/\" )}; var contactsResponse = await client . GetAsync ( \"contacts\" ); var contactList = await contactsResponse . Content . ReadAsAsync < List < Contact >>(); var createResponse = await client . PostAsJsonAsync ( \"contacts\" , new Contact { Name = \"Smith\" }); var contactUri = createResponse . Headers . Location ; //var contactUri = new Uri(\"contacts/1337\", UriKind.Relative); var contactResponse = await client . GetAsync ( contactUri ); var contact = await contactResponse . Content . ReadAsAsync < Contact >(); TypeScript const contactsResponse = await fetch ( \"http://example.com/contacts\" ); const contactList = ( await contactsResponse . json ()) as Contact []; const createResponse = await fetch ( \"http://example.com/contacts\" , { body : JSON.stringify ({ name : \"Smith\" }) }); const contactUri = createResponse . headers . get ( \"Location\" ); //const contactUri = \"http://example.com/contacts/1337\" const contactResponse = await fetch ( contactUri ); const contact = ( await contactResponse . json ()) as Contact ;","title":"The \"old\" way"},{"location":"introduction/#better-with-typedrest","text":"This is where TypedRest comes in. TypedRest is a set of libraries for consuming RESTful APIs that behave in a \"predictable\" way. Rather than applying your knowledge about how a REST collection usually behaves you simply tell TypedRest that this particular endpoint is a collection and get a collection-like interface in return. C# var client = new EntryEndpoint ( new Uri ( \"http://example.com/\" )); var contacts = new CollectionEndpoint < Contact >( client , relativeUri : \"./contacts\" ); var contactList = await contacts . ReadAllAsync (); var smith = await contacts . CreateAsync ( new Contact { Name = \"Smith\" }); //var smith = contacts[\"1337\"]; var contact = await smith . ReadAsync (); TypeScript const client = new EntryEndpoint ( new URL ( \"http://example.com/\" )); const contacts = new CollectionEndpoint < Contact > ( client , \"./contacts\" ); const contactList = await contacts . readAll (); const smith = await contacts . create ({ name : \"Smith\" }); //const smith = contacts.get(\"1337\"); const contact = await smith . read ();","title":"Better with TypedRest"},{"location":"introduction/#endpoints","text":"TypedRest uses an object-oriented approach to provide you with building blocks for modeling RESTful endpoints . Behavior of endpoints is described by inheritance while navigation between them is described by composition. For example, we could redesign our sample from above to make the service's functionality easy to discover and consume using code completion: C# class MyClient : EntryEndpoint { public MyClient ( Uri uri ) : base ( uri ) {} public ICollectionEndpoint < Contact > Contacts => new CollectionEndpoint < Contact >( this , relativeUri : \"./contacts\" ); } TypeScript class MyClient extends EntryEndpoint { get contacts () { return new CollectionEndpoint < Contact > ( this , \"./contacts\" ); } } The consuming code could look this: C# var client = new MyClient ( new Uri ( \"http://example.com/\" )); var contactList = await client . Contacts . ReadAllAsync (); var smith = await client . Contacts . CreateAsync ( new Contact { Name = \"Smith\" }); var contact = await smith . ReadAsync (); TypeScript const client = new MyClient ( new URL ( \"http://example.com/\" )); const contactList = await client . contacts . readAll (); const smith = await client . contacts . create ({ name : \"Smith\" }); const contact = await smith . read ();","title":"Endpoints"},{"location":"introduction/#patterns","text":"TypedRest is all about nomenclature and patterns. An endpoint describes any resource addressable via an URI. An entry endpoint represents the top-level URI of an API. It takes care of shared concerns such as authentication. An element endpoint is a singular resource that can be read, modified and deleted. A collection endpoint can list and add elements as well as provide element endpoints for individual elements. There are also a number of more specialized endpoint types such as streaming-capable collections . Each of these endpoint types has one or more corresponding classes in TypedRest. The only requirement on the server-side is that at least a part of the underlying pattern is implemented. For example, a collection endpoint class works as long as the server responds with an array of elements when GET ting the collection while GET ting a child endpoint provides a specific element of the same type. If adding new elements via POST is not supported (yet) this will simply result in an exception at runtime when calling .CreateAsync() . For more graceful degradation TypedRest also exposes information about \"allowed\" methods as reported by OPTIONS . We consider TypedRest's design to be opinionated yet pragmatic. The path of least resistance is to make your API match the patterns implemented in the built-in classes. These usually align with what is widely considered as \"best practice\". However: We explicitly support some unRESTful concepts such as RPC endpoints. HATEOAS-style, link-based navigation is possible but entirely optional. Link information is preferably encoded in HTTP Link headers instead of response bodies, although the latter is also supported in form of HAL. TypedRest does not use custom MIME types for API versioning, navigation, etc.. Of course, we don't expect our predefined patterns to cover all possible use cases. This where good old \"extension through inheritance\" comes into play. Let's say our sample API from above also allows us to store a note associated with a contact. We need to extend ElementEndpoint for individual Contact instances to expose this functionality. We also need to replace CollectionEndpoint with something that builds instances of our specialized element endpoint rather than using ElementEndpoint . Let's get coding! C# class MyClient : EntryEndpoint { public MyClient ( Uri uri ) : base ( uri ) {} public ContactCollectionEndpoint Contacts => new ContactCollectionEndpoint ( this ); } class ContactCollectionEndpoint : CollectionEndpoint < Contact , ContactEndpoint > { public ContactCollectionEndpoint ( IEndpoint referrer ) : base ( referrer , relativeUri : \"./contacts\" ) {} } class ContactEndpoint : ElementEndpoint < Contact > { public ContactEndpoint ( IEndpoint referrer , Uri relativeUri ) : base ( referrer , relativeUri ) {} public IElementEndpoint < Note > Note => new ElementEndpoint < Note >( this , relativeUri : \"./note\" ); } TypeScript class MyClient extends EntryEndpoint { get contacts () { return new ContactCollectionEndpoint ( this ); } } class ContactCollectionEndpoint extends GenericCollectionEndpoint < Contact , ContactEndpoint > { constructor ( referrer : Endpoint ) { super ( referrer , \"./contacts\" , ContactEndpoint ); } } class ContactEndpoint extends ElementEndpoint < Contact > { get note () { return new ElementEndpoint < Note > ( this , \"./note\" ); } } The consuming code could look this: C# var client = new MyClient ( new Uri ( \"http://example.com/\" )); await client . Contacts [ \"1337\" ]. Note . SetAsync ( new Note { Content = \"some note\" }); TypeScript const client = new MyClient ( new URL ( \"http://example.com/\" )); await client . contacts . get ( \"1337\" ). note . set ({ content : \"some note\" });","title":"Patterns"},{"location":"introduction/#next-steps","text":"Continue on to the Getting started guide.","title":"Next steps"},{"location":"code-generation/","text":"Code generation \u00b6 There is an experimental code generation tool available for TypedRest. This tool automatically infers TypedRest Endpoints from patterns in OpenAPI/Swagger documents and generates source code for TypedRest clients. It currently only supports generating C# clients. Take a look at the project's GitHub repository .","title":"Code generation"},{"location":"code-generation/#code-generation","text":"There is an experimental code generation tool available for TypedRest. This tool automatically infers TypedRest Endpoints from patterns in OpenAPI/Swagger documents and generates source code for TypedRest clients. It currently only supports generating C# clients. Take a look at the project's GitHub repository .","title":"Code generation"},{"location":"endpoints/","text":"Endpoint types \u00b6 Endpoints are the main building blocks of TypedRest. An endpoint represents an URI that provides methods for interacting with a specific resource. The type of the endpoint determines the available methods. An endpoint can also provide child endpoints (represent child URIs) via composition. TypedRest provides a number of endpoint types modelling common REST patterns. Most APIs can be consumed by either directly using these types or by deriving from them and adding additional methods for special use cases. Entry endpoints represent the top-level URI of APIs. Generic endpoints allow you to model collections and elements: Element endpoint - individual resource (read, write, delete) Collection endpoint - collection of entities addressable as elements (read all, create, get child by ID) Indexer endpoint - address child endpoints by ID RPC endpoints allow you to interact with non-RESTful resources that act like callable functions: Action endpoint - no input or output Consumer endpoint - takes entity as input Producer endpoint - produces entity as output Function endpoint - takes entity as input and produces entity as output Raw endpoints allow you to transmit binary data rather than serialized objects: Upload endpoint - accept binary uploads Blob endpoint - download or upload a binary blob Reactive endpoints allow you to receive data as push streams rather than explicitly pulling: Polling endpoint - poll resource for state changes Streaming endpoint - stream of entities via persistent connection Streaming Collection endpoint - collection of entities observable as append-only stream The constructors of all endpoints except entry endpoints take a referrer parameter. This is uses to inherit relative URI bases and configuration such as error handling and link handling .","title":"Endpoint types"},{"location":"endpoints/#endpoint-types","text":"Endpoints are the main building blocks of TypedRest. An endpoint represents an URI that provides methods for interacting with a specific resource. The type of the endpoint determines the available methods. An endpoint can also provide child endpoints (represent child URIs) via composition. TypedRest provides a number of endpoint types modelling common REST patterns. Most APIs can be consumed by either directly using these types or by deriving from them and adding additional methods for special use cases. Entry endpoints represent the top-level URI of APIs. Generic endpoints allow you to model collections and elements: Element endpoint - individual resource (read, write, delete) Collection endpoint - collection of entities addressable as elements (read all, create, get child by ID) Indexer endpoint - address child endpoints by ID RPC endpoints allow you to interact with non-RESTful resources that act like callable functions: Action endpoint - no input or output Consumer endpoint - takes entity as input Producer endpoint - produces entity as output Function endpoint - takes entity as input and produces entity as output Raw endpoints allow you to transmit binary data rather than serialized objects: Upload endpoint - accept binary uploads Blob endpoint - download or upload a binary blob Reactive endpoints allow you to receive data as push streams rather than explicitly pulling: Polling endpoint - poll resource for state changes Streaming endpoint - stream of entities via persistent connection Streaming Collection endpoint - collection of entities observable as append-only stream The constructors of all endpoints except entry endpoints take a referrer parameter. This is uses to inherit relative URI bases and configuration such as error handling and link handling .","title":"Endpoint types"},{"location":"endpoints/entry/","text":"Entry endpoint \u00b6 Represent the top-level URI of an API. Used to address the various resources of the API. The constructor of the entry endpoint requires you to specify the APIs root URL. It also provides optional parameters to override the default HTTP client, JSON serializer, error handler and link handler .","title":"Entry endpoint"},{"location":"endpoints/entry/#entry-endpoint","text":"Represent the top-level URI of an API. Used to address the various resources of the API. The constructor of the entry endpoint requires you to specify the APIs root URL. It also provides optional parameters to override the default HTTP client, JSON serializer, error handler and link handler .","title":"Entry endpoint"},{"location":"endpoints/generic/collection/","text":"Collection endpoint \u00b6 Endpoint for a collection of entities addressable as Element endpoints . Method Input Result HTTP Verb Description Get ID / Entity Endpoint - Get an Element endpoint for a specific child element. Read all - Entities GET Returns all entities in the collection. Read range Range Entities GET Returns all entities within a specific range of the collection. Create Entity - POST Adds an entity as a new element to the collection. Create All Entities - PATCH Adds (or updates) multiple entities as elements in the collection. Set All Entities - PUT Replaces the entire content of the collection with new entities. Extends Indexer endpoint","title":"Collection endpoint"},{"location":"endpoints/generic/collection/#collection-endpoint","text":"Endpoint for a collection of entities addressable as Element endpoints . Method Input Result HTTP Verb Description Get ID / Entity Endpoint - Get an Element endpoint for a specific child element. Read all - Entities GET Returns all entities in the collection. Read range Range Entities GET Returns all entities within a specific range of the collection. Create Entity - POST Adds an entity as a new element to the collection. Create All Entities - PATCH Adds (or updates) multiple entities as elements in the collection. Set All Entities - PUT Replaces the entire content of the collection with new entities. Extends Indexer endpoint","title":"Collection endpoint"},{"location":"endpoints/generic/element/","text":"Element endpoint \u00b6 Endpoint for an individual resource. Method Input Result HTTP Verb Description Exists - Boolean HEAD Determines whether the element currently exists. Read - Entity GET Returns the entity. Set Entity Entity PUT Sets/replaces the entity. Merge Entity Entity PATCH Modifies the existing entity by merging changes. Delete - - DELETE Deletes the element.","title":"Element endpoint"},{"location":"endpoints/generic/element/#element-endpoint","text":"Endpoint for an individual resource. Method Input Result HTTP Verb Description Exists - Boolean HEAD Determines whether the element currently exists. Read - Entity GET Returns the entity. Set Entity Entity PUT Sets/replaces the entity. Merge Entity Entity PATCH Modifies the existing entity by merging changes. Delete - - DELETE Deletes the element.","title":"Element endpoint"},{"location":"endpoints/generic/indexer/","text":"Indexer endpoint \u00b6 Endpoint that addresses child endpoints by ID. Method Input Result HTTP Verb Description Get ID Endpoint - Get an Element endpoint for a specific child element.","title":"Indexer endpoint"},{"location":"endpoints/generic/indexer/#indexer-endpoint","text":"Endpoint that addresses child endpoints by ID. Method Input Result HTTP Verb Description Get ID Endpoint - Get an Element endpoint for a specific child element.","title":"Indexer endpoint"},{"location":"endpoints/raw/blob/","text":"Blob endpoint \u00b6 Endpoint for a binary blob that can be downloaded or uploaded. Method Input Result HTTP Verb Description Download - Binary data GET Downloads the blob's content. Upload Binary data - PUT Uploads content for the blob.","title":"Blob endpoint"},{"location":"endpoints/raw/blob/#blob-endpoint","text":"Endpoint for a binary blob that can be downloaded or uploaded. Method Input Result HTTP Verb Description Download - Binary data GET Downloads the blob's content. Upload Binary data - PUT Uploads content for the blob.","title":"Blob endpoint"},{"location":"endpoints/raw/upload/","text":"Upload endpoint \u00b6 Endpoint that accepts binary uploads. Method Input Result HTTP Verb Description Upload Binary data - POST Uploads data to the endpoint.","title":"Upload endpoint"},{"location":"endpoints/raw/upload/#upload-endpoint","text":"Endpoint that accepts binary uploads. Method Input Result HTTP Verb Description Upload Binary data - POST Uploads data to the endpoint.","title":"Upload endpoint"},{"location":"endpoints/reactive/polling/","text":"Polling endpoint \u00b6 Endpoint for a resource that can be polled for state changes. Method Input Result HTTP Verb Description Get observable - Entity stream GET Provides an observable stream of entity states. Exists - Boolean HEAD Determines whether the element currently exists. Read - Entity GET Returns the entity. Set Entity Entity PUT Sets/replaces the entity. Merge Entity Entity PATCH Modifies the existing entity by merging changes. Delete - - DELETE Deletes the element. Extends Element endpoint","title":"Polling endpoint"},{"location":"endpoints/reactive/polling/#polling-endpoint","text":"Endpoint for a resource that can be polled for state changes. Method Input Result HTTP Verb Description Get observable - Entity stream GET Provides an observable stream of entity states. Exists - Boolean HEAD Determines whether the element currently exists. Read - Entity GET Returns the entity. Set Entity Entity PUT Sets/replaces the entity. Merge Entity Entity PATCH Modifies the existing entity by merging changes. Delete - - DELETE Deletes the element. Extends Element endpoint","title":"Polling endpoint"},{"location":"endpoints/reactive/streaming-collection/","text":"Streaming Collection endpoint \u00b6 Endpoint for a collection of entities observable as an append-only stream using long-polling. Method Input Result HTTP Verb Description Get observable - Entity stream GET Provides an observable stream of elements. Get ID / Entity Endpoint - Get an Element endpoint for a specific child element. Read all - Entities GET Returns all entities in the collection. Read range Range Entities GET Returns all entities within a specific range of the collection. Create Entity - POST Adds an entity as a new element to the collection. Create All Entities - PATCH Adds (or updates) multiple entities as elements in the collection. Set All Entities - PUT Replaces the entire content of the collection with new entities. Extends Collection endpoint","title":"Streaming Collection endpoint"},{"location":"endpoints/reactive/streaming-collection/#streaming-collection-endpoint","text":"Endpoint for a collection of entities observable as an append-only stream using long-polling. Method Input Result HTTP Verb Description Get observable - Entity stream GET Provides an observable stream of elements. Get ID / Entity Endpoint - Get an Element endpoint for a specific child element. Read all - Entities GET Returns all entities in the collection. Read range Range Entities GET Returns all entities within a specific range of the collection. Create Entity - POST Adds an entity as a new element to the collection. Create All Entities - PATCH Adds (or updates) multiple entities as elements in the collection. Set All Entities - PUT Replaces the entire content of the collection with new entities. Extends Collection endpoint","title":"Streaming Collection endpoint"},{"location":"endpoints/reactive/streaming/","text":"Streaming endpoint \u00b6 Endpoint for a stream of entities using a persistent HTTP connection. Method Input Result HTTP Verb Description Get observable - Entity stream GET Provides an observable stream of entities.","title":"Streaming endpoint"},{"location":"endpoints/reactive/streaming/#streaming-endpoint","text":"Endpoint for a stream of entities using a persistent HTTP connection. Method Input Result HTTP Verb Description Get observable - Entity stream GET Provides an observable stream of entities.","title":"Streaming endpoint"},{"location":"endpoints/rpc/action/","text":"Action endpoint \u00b6 RPC endpoint that is invoked with no input or output. Method Input Result HTTP Verb Description Invoke - - POST Invokes the action.","title":"Action endpoint"},{"location":"endpoints/rpc/action/#action-endpoint","text":"RPC endpoint that is invoked with no input or output. Method Input Result HTTP Verb Description Invoke - - POST Invokes the action.","title":"Action endpoint"},{"location":"endpoints/rpc/consumer/","text":"Consumer endpoint \u00b6 RPC endpoint that takes an entity as input when invoked. Method Input Result HTTP Verb Description Invoke Entity - POST Sends the entity to the consumer.","title":"Consumer endpoint"},{"location":"endpoints/rpc/consumer/#consumer-endpoint","text":"RPC endpoint that takes an entity as input when invoked. Method Input Result HTTP Verb Description Invoke Entity - POST Sends the entity to the consumer.","title":"Consumer endpoint"},{"location":"endpoints/rpc/function/","text":"Function endpoint \u00b6 RPC endpoint that takes an entity as input and returns another entity as output when invoked. Method Input Result HTTP Verb Description Invoke Entity Entity POST Invokes the function.","title":"Function endpoint"},{"location":"endpoints/rpc/function/#function-endpoint","text":"RPC endpoint that takes an entity as input and returns another entity as output when invoked. Method Input Result HTTP Verb Description Invoke Entity Entity POST Invokes the function.","title":"Function endpoint"},{"location":"endpoints/rpc/producer/","text":"Producer endpoint \u00b6 RPC endpoint that returns an entity as output when invoked. Method Input Result HTTP Verb Description Invoke - Entity POST Gets an entity from the producer.","title":"Producer endpoint"},{"location":"endpoints/rpc/producer/#producer-endpoint","text":"RPC endpoint that returns an entity as output when invoked. Method Input Result HTTP Verb Description Invoke - Entity POST Gets an entity from the producer.","title":"Producer endpoint"},{"location":"error-handling/","text":"Exception mapping \u00b6 TypedRest maps non-success HTTP Status (4xx and 5xx) to exceptions/errors. The following mappings are applied by default: HTTP Status Code .NET Exception JavaScript Error 400 Bad Request InvalidDataException BadRequestError 401 Unauthorized AuthenticationException AuthenticationError 403 Forbidden UnauthorizedAccessException AuthorizationError 404 NotFound or 410 Gone KeyNotFoundException NotFoundError 408 Request Timeout TimeoutException TimeoutError 409 Conflict InvalidOperationException ConflictError 412 Precondition Failed InvalidOperationException ConcurrencyError 416 Range Not Satisfiable InvalidOperationException RangeError other HttpRequestException HttpError","title":"Exception mapping"},{"location":"error-handling/#exception-mapping","text":"TypedRest maps non-success HTTP Status (4xx and 5xx) to exceptions/errors. The following mappings are applied by default: HTTP Status Code .NET Exception JavaScript Error 400 Bad Request InvalidDataException BadRequestError 401 Unauthorized AuthenticationException AuthenticationError 403 Forbidden UnauthorizedAccessException AuthorizationError 404 NotFound or 410 Gone KeyNotFoundException NotFoundError 408 Request Timeout TimeoutException TimeoutError 409 Conflict InvalidOperationException ConflictError 412 Precondition Failed InvalidOperationException ConcurrencyError 416 Range Not Satisfiable InvalidOperationException RangeError other HttpRequestException HttpError","title":"Exception mapping"},{"location":"getting-started/","text":"Getting started \u00b6 TypedRest is available for multiple platforms/languages. Please choose one of the following Getting Started Guides: .NET (C#, VB.NET, F#, etc.) Java (Java and Kotlin) TypeScript","title":"Getting started"},{"location":"getting-started/#getting-started","text":"TypedRest is available for multiple platforms/languages. Please choose one of the following Getting Started Guides: .NET (C#, VB.NET, F#, etc.) Java (Java and Kotlin) TypeScript","title":"Getting started"},{"location":"getting-started/dotnet/","text":".NET \u00b6 Dependencies \u00b6 Add one or more of the following NuGet packages to your project: TypedRest The main TypedRest library. TypedRest.Reactive Adds support for streaming with ReactiveX (Rx) to TypedRest. TypedRest.OAuth Provides an HttpClient DelegatingHandler for OAuth 2.0 / OpenID Connect authentication. This can also be used independently of the other TypedRest packages. TypedRest.CommandLine Build command-line interfaces for TypedRest clients. Dependency Injection \u00b6 If you wish to use TypedRest in an ASP.NET Core web service (or any other kind of service that uses IServiceProvider -based dependency injection) you can use the .AddTypedRest<T>() extension method. This registers the endpoint you specify for dependency injection and connects it with HttpClientFactory . See also \u00b6 API documentation GitHub repository Sample project","title":".NET"},{"location":"getting-started/dotnet/#net","text":"","title":".NET"},{"location":"getting-started/dotnet/#dependencies","text":"Add one or more of the following NuGet packages to your project: TypedRest The main TypedRest library. TypedRest.Reactive Adds support for streaming with ReactiveX (Rx) to TypedRest. TypedRest.OAuth Provides an HttpClient DelegatingHandler for OAuth 2.0 / OpenID Connect authentication. This can also be used independently of the other TypedRest packages. TypedRest.CommandLine Build command-line interfaces for TypedRest clients.","title":"Dependencies"},{"location":"getting-started/dotnet/#dependency-injection","text":"If you wish to use TypedRest in an ASP.NET Core web service (or any other kind of service that uses IServiceProvider -based dependency injection) you can use the .AddTypedRest<T>() extension method. This registers the endpoint you specify for dependency injection and connects it with HttpClientFactory .","title":"Dependency Injection"},{"location":"getting-started/dotnet/#see-also","text":"API documentation GitHub repository Sample project","title":"See also"},{"location":"getting-started/java/","text":"Java \u00b6 Dependencies \u00b6 Add one or more of the following Maven artifacts to your project: typedrest-core The main TypedRest library. typedrest-annotations Annotations for data models to be used with TypedRest. typedrest-vaadin Build Vaadin GUIs for TypedRest clients. See also \u00b6 API documentation GitHub repository","title":"Java"},{"location":"getting-started/java/#java","text":"","title":"Java"},{"location":"getting-started/java/#dependencies","text":"Add one or more of the following Maven artifacts to your project: typedrest-core The main TypedRest library. typedrest-annotations Annotations for data models to be used with TypedRest. typedrest-vaadin Build Vaadin GUIs for TypedRest clients.","title":"Dependencies"},{"location":"getting-started/java/#see-also","text":"API documentation GitHub repository","title":"See also"},{"location":"getting-started/typescript/","text":"TypeScript \u00b6 Dependencies \u00b6 Add the typescript NPM package to your project: npm install typedrest --save See also \u00b6 API documentation GitHub repository","title":"TypeScript"},{"location":"getting-started/typescript/#typescript","text":"","title":"TypeScript"},{"location":"getting-started/typescript/#dependencies","text":"Add the typescript NPM package to your project: npm install typedrest --save","title":"Dependencies"},{"location":"getting-started/typescript/#see-also","text":"API documentation GitHub repository","title":"See also"},{"location":"link-handling/","text":"Link handling \u00b6 TypedRest supports a variety of different links: Hard-coded relative URIs between endpoints Links transmitted via the HTTP Link Header Links encoded in resources via HAL URI templates","title":"Link handling"},{"location":"link-handling/#link-handling","text":"TypedRest supports a variety of different links: Hard-coded relative URIs between endpoints Links transmitted via the HTTP Link Header Links encoded in resources via HAL URI templates","title":"Link handling"}]}